# python-coding-interview

> 4/18 (mon)

<br/>

# 최단 경로 문제
- 각 간선의 가중치 합이 최소가 되는 두 정점(또는 노드) 사이의 경로를 찾음
- 정점 : 교차로, 간선 : 길, 가중치 : 거리나 시간과 같은 이동 비용
- 그래프의 종류와 특성에 따라 각각 최적화된 다양한 최단 경로 알고리즘이 존재
    - 다익스트라 Dijkstra 알고리즘 

<br/>

### # 참고 : 오컴이 면도날
- 어떤 현상을 설명할 때 필요 이상의 가정과 개념들은 면도날로 베어낼 필요가 있다는 권고로 쓰임
- 즉 사고의 절약을 요구하는 원리
- 단순한 과학적 설명을 선호하고, 적은 과정으로 자연 현상을 많이 설명할 수 있는 이로능ㄹ 복잡한 이론보다 더 선호한다.
- 최대 만족, 최소 비용이라는 경제적 원리가 여기에 적용된다.

<br/>

### # 참고 : 다익스트라 알고리즘
- 항상 노드 주변의 최단 경로만을 택하는 대표적인 그리디Greedy 알고리즘
- 단순하고 실행 속도 또한 빠르다.
- 노드 주변을 탐색할 때 너비 우선 탐색(BFS)를 이용하는 대표적인 알고리즘이다.

# 40. 네트워크 딜레이 타임 [Network Delay Time](https://leetcode.com/problems/network-delay-time/)
K부터 출발해 모든 노드가 신호를 받을 수 있는 시간을 계산하라. 불가능할 경우 -1을 리턴한다. 입력값(u, v, w)는 각각 출발지, 도착지, 소요 시간으로 구성되며, 전체 노드의 갯수는 N으로 입력받는다.

<br/>

### # 예제 
- 입력
```times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]], N = 4, K = 2```
- 출력
```2```

<br/><br/>

# 41. K 경유지 내 가장 저렴한 항공권 [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-whithin-k-stops/)
시작점에서 도착점까지의 가장 저렴한 가격을 계산하되, K개의 경유지 이내에 도착하는 가격을 리턴하라. 경로가 존재하지 않을 경우 -1을 리턴하라.

<br/>

### # 예제 
- 입력
```n = 3, flights = [[0, 1, 100], [1,2,100], [0,2,500]], src = 0, dst = 2, K = 0```
- 출력
```500```
