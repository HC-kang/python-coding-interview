# python-coding-interview

> 3/23 (wed)

<br/>

# 연결 리스트

<br/>

## # 연결 리스트
- 데이터 요소의 선형 집합
- 데이터의 순서가 메모리에 물리적인 순서대로 저장되지 않음
- 추상 자료형Abstract Data Type(ADT) 구현의 기반이 됨
- 장점 : 
    - 동적으로 새로운 노드를 삽입, 삭제하기 간편
    - 연결 구조를 통해 물리 메모리를 연속적으로 사용하지 않아도 되기에 관리에 편리
    - 데이터를 구조체로 묶어 포인터로 연결하여 다양하게 활용 가능
- 단점 : 
    - 배열과 달리 특정 인덱스에 접근하기 위해 전체 순서대로 읽어야 함 -> 상수 시간에 접근 못함
    - 탐색에는 O(n)이 소요됨

<br/><br/>

# 13. 팰린드롬 연결 리스트 [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)
연결 리스트가 팰린드롬 구조인지 판별하라

<br/>

### # 예제 1
- 입력
```1->2```
- 출력
```false```

### # 예제 2
- 입력
```1->2->2->1```
- 출력
```true```

<br/>

### 참고 : Runner 기법
- 연결 리스트를 순회할 때 2개의 포인터(빠른 러너, 느린 러너)를 동시에 사용하는 기법
- 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용함
- 대개 빠른 러너는 두 칸씩 건너뛰고, 느린 러너는 한 칸씩 이동
- 빠른 러너가 연결 리스트의 끝에 도달하면, 느린 러너는 정확히 연결 리스트의 중간 지점을 가리킴
- 중간 위치를 찾아내면, 이때부터 값을 비교 및 뒤집기 등으로 활용하여 풀이

<br/>

### 문법 : 다중 할당 Multiple Assignment
- 2개 이상의 값을  2개 이상의 변수에 동시에 할당하는 것
```
a, b = 1, 2

>>> a
1

>>> b
2
```
- 파이썬에는 원시 타입 Primitive Types가 존재하지 않지만, 모든 것이 객체다.
- 문자와 숫자의 경우 불변 객체 Immutable Object, = 연산자로 할당하면 값을 할당하는 것이 아니라 불변 객체에 대한 참조를 할당하게 된다.
```
>>> id(5)
4513566608

>>> a = 5
>>> id(a)
4513566608

>>> b = 5
>>> id(b)
4513566608
```

<br/><br/>

# 14. 두 정렬 리스트의 병합 [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
정렬되어 있는 두 연결 리스트를 합쳐라.

<br/>

### # 예제 1
- 입력
```1->2->4, 1->3->4```
- 출력
```1->1->2->3->4->4```

<br/>

### 파이썬 : 연산자 우선순위
| 우선순위 | 연산자 | 설명 |
| ------- | ------ | --- | 
| 1 | ( ) | 괄호 |
| 2 | f(args...) | 함수호출 |
| 3 | x[index:tndex] | 슬라이싱 |
| 4 | x[index] | 배열 |
| 5 | x.attribute | 속성참조 |
| 6 | ** | 지수 |
| 7 | ~x | 비트 연산 NOT |
| 8 | +x, -x | 양수,음수 |
| 9 | * /, % | 곱, 나눗셈, 나머지 |
| 10 | +, - | 덧셈, 뺄셈 |
| 11 | «, » | 비트 연산 시프트 |
| 12 | & | 비트 연산 AND |
| 13 | ^ | 비트 연산 XOR |
| 14 | \| | 비트 연산 0R |
| 15 | in, not in, is, is not, <, <=, >, >=, o, != == | 비교 연산 |
| 16 | not x | 부울 연산 NOT |
| 17 | and | 부울 연산 AND |
| 18 | or | 부울 연산 0R |
| 19 | lambda | 람다 표현 |
- 실행 순서가 모호할 때는 모든 연산자 중 가장 먼저 실행되는 괄호부터 씌우자.

<br/>

### 문법 : 변수 스왑
- 별 이슈가 없는 한 가독성 또한 좋은 다중 할당 방식으로 스왑하는 게 가장 좋다.

<br/><br/>

# 15. 역순 연결 리스트 [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)
연결 리스트를 뒤집어라.

<br/>

### # 예제 1
- 입력
```1->2->3->4->5->NULL```
- 출력
```5->4->3->2->1->NULL```

<br/><br/>

# 16. 두 수의 덧셈 [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
역순으로 저장된 연결 리스트의 숫자를 더하라.

<br/>

### # 예제 1
- 입력
```(2->4->3) + (5->6->4)```
- 출력
```7->8->0```
- 설명
```342+465=807```

<br/>

### 문법 : 숫자형 리스트를 단일 값으로 병합하기
```
a = [1, 2, 3, 4, 5]

>>> ''.join(map(str, a)
'12345'

>>> functools.reduce(lambda x, y: 10 * x + y, a, 0)
'12345'

>>> functools.reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])
15
((((1+2)+3)+4)+5)

>>> from operator import add, mul
>>> functools. reduce(add, [1, 2, 3, 4, 5])
15
>>> functools. reduce(mul, [1, 2, 3, 4, 5])
120
```
- functools : 함수를 다루는 함수로, 고계 함수 Higher-Order Function을 지원하는 함수형 언어 모듈이다.
- operator : 연산자 명칭(함수)를 reduce() 메소드의 파라미터로 지정하여 가독성을 높인다. 

<br/><br/>

# 17. 페어의 노드 스왑 [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)
연결 리스트를 입력받아 페어 단위로 스왑하라

<br/>

### # 예제 1
- 입력
```1->2->3->4```
- 출력
```2->1->4->3```

<br/><br/>

# 18. 홀짝 연결 리스트 [Odd Even Linked List](https://leetcode.com/problems/Odd-even-linked-list/)
연결 리스트를 홀수 노드 다음에 짝수 노드가 오도록 재구성하라. 공간 복잡도 O(1), 시간 복잡도 O(n)에 풀이하라.

<br/>

### # 예제 1
- 입력
```1->2->3->4->5->Null```
- 출력
```1->3->5->2->4->Null```

### # 예제 2
- 입력
```2->1->3->5->6->4->7->Null```
- 출력
```2->3->6->7->1->5->4->Null```

<br/><br/>

# 19. 역순 연결 리스트 2 [Reverse Linked List 2](https://leetcode.com/problems/reverse-linked-list-ii/)
인덱스 m에서 n까지를 역순으로 만들어라. 인덱스 m은 1부터 시작한다.

<br/>

### # 예제 1
- 입력
```1->2->3->4->5->Null, m=2, n=4```
- 출력
```1->4->3->2->5->Null```

<br/>