# python-coding-interview

> 4/17 ()

<br/>

# 비선형 자료구조
- 데이터 요소가 순차적(Sequential)으로 또는 선형으로 배열되지 않는 자료구조
- 선혀오가 달리 멀티 레벨로 구성된다.
- 탐색이 복잡하고 선형에 비해 다소 번잡한 편이나, 메모리를 좀 더 효율적으로 활용할 수 있다.
- 대표적 : 그래프, 트리 

<br/>

# # 그래프
- 객체의 일부 쌍pair들이 연관되어 있는 객체 집합 구조

<br/>

## # 오일러 경로
- 그래프 구조의 원형
- Vertex정점, Edge간선으로 구성된 그래프
- 모든 정점이 짝수 개의 차수Degree를 갖는다면 모든 다리를 한 번씩만 건너서 도달하는 것이 성립됨
- ex. 한 번도 붓을 떼지 않고 모든 간선을 한 번씩만 그리는 한붓 그리기
- 간선 기준

<br/>

## # 해밀턴 경로
- 각 정점을 한 번씩 방문하는 무향 또는 유향 그래프 경로
- 최적 알고리즘이 없는 대표적인 NP-완전 문제
- 원래의 출발점으로 돌아오는 경로를 해밀턴 순환이라고 하고, 최단 거리를 찾는 문제는 외판원 문제Travelling Salesman Problem이라고 함
- 정점 기준

<br/>

## # 경로
- 해밀턴 경로 : 한 번만 방문하는 경로
- 해밀턴 순환 : 한 번만 방문하여 출발지로 돌아오는 경로
- 외판원 문제 : 한 번만 방문하여 출발지로 돌아오는 경로 중 가장 짧은 경로

<br/>

### 참고 : NP 복잡도
- NP: Non-deterministic Polynomial time의 약자
- 비결정론적 튜링 기계(NTM)로 다항 시간 안에 풀 수 있는 판정 문제의 집합
- 결정론적 튜링 기계로 다항 시간에 검증이 가능하고 그 역도 성립

<br/>

## # 그래프 순회
- 그래프 탐색
- 그래프의 각 정점을 방문하는 과정
- 알고리즘 : 우선 탐색, 너비 우선 탐색
    1. 우선 탐색 Depth-First Search DFS
        - 주로 스택 및 재귀로 구현
        - 백트래킹 통해 뛰어난 효용 보임
    2. 너비 우선 탐색 Breadth-First Search BFS
        - 주로 큐로 구현
        - 그래프의 최단 경로 구하는 문제 해결
- 그래프 표현하는 방법 : 인접 행렬 Adjacency Matrix, 인접 리스트 Adjacency List
    - 인접 리스트
        - 출발 노드를 키로, 도착 노드를 값으로 표현할 수 있다.
        - 도착 노드는 여러 개가 될 수 있으므로 리스트 형태가 된다.

<br/>

## # 백트래킹 Backtracking
- 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제에 특히 유용하다.
- 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다는 데서 유래했다.
- 최악의 경우에는 모든 경우를 다 거친 후에야 다음에 도착할 수 있어, 브루트 포스와 유사하다.
- 하지만 한번 방문 후 가능성이 없는 경우에는 즉시 포기한다는 점에서 브루트 포스보단 낫다.

<br/>

## # 제약 충족 문제 Constraint Satisfaction Problems
- 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제
- 인공지능이나 경영 과학 분야에서 심도 있게 연구되고 있음
- 합리적인 시간 내에 풀기 위해 휴리스틱과 조합 탐색 같은 개념과 함께 결합하여 풀이 된다.
- 백트래킹을 하면서 가지치기(불필요한 부분 일찍 버림)를 통해 최적화하는 형태로 풀이한다.
- 예. 스도쿠, 십자말 풀이, 8퀸 문제, 4색 문제, 배낭 문제, 문자열 파싱, 조합 최적화 문제 등 

<br/><br/>

# 32. 섬의 개수 [Number of Islands](https://leetcode.com/problems/number-of-islands/)
1을 육지로, 0을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 개수를 계산하라.
(연결되어 있는 1의 덩어리 개수를 구하라.)

<br/>

### # 예제 1
- 입력
```11110, 11010, 11000, 00000```
- 출력
```1```

### # 예제 2
- 입력
```11000, 11000, 00100, 00011```
- 출력
```3```

<br/>

## # 파이썬 : 중첩 함수
- 함수 내에 위치한 또 다른 함수, 바깥에 위치한 함수들과 달리 부모 함수의 변수를 자유롭게 읽을 수 있다.
- 아무런 파라미터도 넘기지 않았지만 부모 함수의 변수를 자유롭게 읽어들여 구현이 깔끔해진다.
- 가변 객체인 경우도 여러 가지 연산으로 조작도 가능하다.
- 하지만 재할당(=)이 일어날 경우 참조 id가 변경되어 별도의 로컬 변수로 선언된다.

<br/><br/>

# 33. 전화 번호 문자 조합 [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)
2에서 9까지 숫자가 주어졌을 때 전화 번호로 조합 가능한 모든 문자를 출력하라.

<br/>

### # 예제 
- 입력
```"23"```
- 출력
```["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]```

<br/><br/>

# 34. 순열 [Permutations](https://leetcode.com/problems/permutations/)
서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라.

<br/>

### # 예제 
- 입력
```[1, 2, 3]```
- 출력
```[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]```

<br/>

## # 문법 : 객체 복사
- 파이썬의 중요한 특징 중 하나는 모든 것이 객체라는 점이다.
- 숫자, 문자가 리스트, 딕셔너리와 같은 객체와의 차이점이라면 불변 객체라는 점이다.
- 값을 복사하지 않는 한, 변수에 값을 할당하는 모든 행위는 값 객체에 대한 참조가 된다.
- 즉, 참조가 가리키는 원래의 값을 변경하면 모든 참조, 모든 변수의 값 또한 함께 변경된다는 말이다.
- [:], copy(), deepcopy()로 처리

<br/><br/>

# 35. 조합 [Combinations](https://leetcode.com/problems/combinations/)
전체 수 n을 입력받아 k개의 조합을 리턴하라

<br/>

### # 예제 
- 입력
```n=4, k=2```
- 출력
```[[2, 4], [3, 4], [2, 3], [1, 2], [1, 3], [1, 4]]```

<br/>

## # 참고 : 순열과 조합
- 경우의 수를 구할 때, 모든 경우의 수를 하나씩 세기보다는 공식을 이용하면 더 빠르게 계산할 수 있다. 이때 식으로 이용한다.
- 순열은 순서를 보지만 조합은 순서를 보지 않는다.

<br/><br/>

# 36. 조합의 합 [Combination Sum](https://leetcode.com/problems/combination-sum/)
숫자 집합 andidates를 조합하여 합이 target이 되는 원소를 나열하라. 각 원소는 중복으로 나열 가능하다.

<br/>

### # 예제 1
- 입력
```candidates = [2,3,6,7], target = 7```
- 출력
```[[7], [2,2,3]]```

<br/>

### # 예제 2
- 입력
```candidates = [2,3,5], target = 8```
- 출력
```[[2,2,2,2], [2,3,3], [3,5]]```

<br/><br/>

# 37. 부분 집합 [Subsets](https://leetcode.com/problems/subsets/)
모든 부분 집합을 리턴하라.

<br/>

### # 예제 1
- 입력
```nums = [1,2,3]```
- 출력
```[[3], [1], [2], [1,2,3], [1,3], [1,2], [2,3], [1,2], []]```

<br/><br/>

# 38. 일정 재구성 [Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)
[from, to]로 구성된 항공권 목록을 이용해 JFK에서 출발하는 여행 일정을 구성하라. 여러 일정이 잇는 경우 사전 어휘 순 Lexical Order으로 방문한다. 

<br/>

### # 예제 1
- 입력
```[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]```
- 출력
```["JFK", "MUC", "LHR", "SFO", "SJC"]```

<br/>

### # 예제 2
- 입력
```[["JFK", "SFO"], ["JFK", "ALT"], ["SFO", "ALT"], ["ALT", "JFK"], ["ALT", "SFO"]]```
- 출력
```["JFK", "ATL", "JFK", "SFO", "ALT", "SFO"]```

<br/><br/>

# 39. 코스 스케줄 [Course Schedule](https://leetcode.com/problems/course-schedule/)
0을 완료하기 위해서는 1을 끝내야 한다는 것을 [0, 1] 쌍으로 표현하는 n개의 코스가 있다. 코스 개수 n개의 코스가 있다. 코스 개수 n과 이 쌍들을 입력으로 받았을 때 모든 코스가 완료 가능한지 판별하라.

<br/>

### # 예제 1
- 입력
```numCourses1 = 2, prerequisites1 = [[1,0]]```
- 출력
```true```

<br/>

### # 예제 2
- 입력
```numCourses2 = 2, prerequisites2 = [[1,0], [0,1]]```
- 출력
```false```

<br/>

## # 파이썬 : defaultdict 순회 문제

<br/><br/>
